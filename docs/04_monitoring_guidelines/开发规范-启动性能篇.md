# 开发规范 - iOS 启动性能篇 V1.1

## 1. 背景与目的

应用启动速度是用户体验的关键一环。缓慢的启动会导致用户流失和满意度下降。本规范旨在总结启动性能优化的最佳实践，指导开发人员在日常编码中规避常见的性能陷阱，共同维护和提升应用的启动速度。

所有团队成员应理解并遵守本规范，将启动性能视为编码质量的重要组成部分。

## 2. Pre-main 阶段规范 (dyld & Runtime - Objective-C & Swift)

### 2.1 Objective-C: 谨慎使用 `+load` 方法

`+load` 方法在类加载时同步执行，是 Pre-main 耗时的主要元凶之一。

*   **【强制】禁止滥用 `+load`**: 避免在 `+load` 中执行任何耗时操作，包括但不限于：
    *   文件 I/O (读/写)
    *   网络请求 (同步/异步)
    *   复杂的计算或数据处理
    *   创建和初始化复杂的对象或单例
    *   `dispatch_sync` 到主队列或其他队列
*   **【推荐】优先使用 `+initialize`**: 对于只需要执行一次的类初始化逻辑（例如注册类、设置默认值），优先使用 `+initialize`。`+initialize` 在类首次收到消息时执行，是惰性加载的，且由 runtime 保证线程安全。
*   **【推荐】使用懒加载替代**: 对于单例或全局状态的初始化，应使用 `dispatch_once` 或其他懒加载模式，在首次访问时才进行初始化。
*   **【必须】方法交换 (Swizzling) 需评估**: 如果必须使用 `+load` 进行方法交换，确保交换逻辑本身非常轻量，且不在 `+load` 中执行交换之外的其他操作。评估是否可以将交换延迟到 `+initialize` 或其他更晚的时机。
*   **【流程】新增 `+load` 需 Code Review**: 任何新增的 `+load` 方法必须经过 Code Review 严格审查其必要性和实现。

### 2.2 Swift: 管理初始化时机

Swift 没有 `+load`，但全局变量、静态属性和复杂的类型初始化也可能在 Pre-main 或 Main 阶段早期执行，影响启动。

*   **【强制】避免在全局变量/常量初始化中执行耗时操作**:
    *   全局 `var` 或 `let` 的初始化表达式应尽可能简单。避免文件 I/O、网络、复杂计算或依赖其他可能未初始化状态的操作。
    *   ```swift
        // Bad: 全局变量初始化时执行耗时操作
        let globalData = try? Data(contentsOf: someFileURL) // 文件 IO
        let complexGlobalState = calculateComplexValue() // 复杂计算

        // Good: 延迟计算或使用简单值
        let simpleGlobalFlag = true
        lazy var lazyGlobalData: Data? = { try? Data(contentsOf: someFileURL) }() // 使用 lazy
        ```
*   **【推荐】善用 Swift 静态属性的懒加载**: Swift `static let` 和 `static var` 的初始化默认是惰性的（类似 `dispatch_once`），并且是线程安全的。只有在首次访问时才会执行初始化代码。尽量利用此特性，避免不必要的早期初始化。
    *   ```swift
        class MyManager {
            // Good: 默认懒加载，只在首次访问 MyManager.shared 时初始化
            static let shared = MyManager()

            private init() {
                // 执行初始化... (如果这里耗时，首次访问会慢)
            }
        }
        ```
*   **【建议】警惕复杂的自定义类型初始化**: 如果自定义的 `struct` 或 `class` 的 `init()` 方法非常耗时，并且这些类型的实例在启动路径上（例如作为全局变量或 App Delegate 的属性）被创建，也会拖慢启动。考虑简化 `init` 或延迟创建。

### 2.3 控制动态库数量与大小 (通用)

过多的动态库会增加 dyld 的加载和链接时间。

*   **【建议】合并动态库**: 对于内部业务模块，评估将多个小型动态库合并为较少数量的大型动态库的可能性。
*   **【建议】移除无用依赖**: 定期检查并移除不再使用的第三方库或内部库依赖。
*   **【建议】静态库优先**: 如果可能，优先考虑使用静态库 (`.a`) 而不是动态库 (`.framework`)，特别是对于代码量不大的工具库。

### 2.4 减少导出的符号 (Symbol) (通用)

大量的导出符号会增加 Rebase/Binding 的时间。

*   **【建议】限制符号可见性**: 在 C/C++/Objective-C 代码中，尽可能使用 `static` 或匿名命名空间 (C++) 来限制函数和变量的作用域，减少不必要的符号导出。对于 Objective-C 类和方法，默认是导出的。

## 3. Main 阶段规范 (`didFinishLaunchingWithOptions` 及之后 - Objective-C & Swift)

### 3.1 保持 `didFinishLaunchingWithOptions` 轻量 (通用)

`didFinishLaunchingWithOptions:` 是启动流程的关键路径，必须保持简洁、快速。

*   **【强制】禁止在 `didFinishLaunchingWithOptions:` 中执行耗时操作**: 避免任何可能阻塞主线程超过几十毫秒的操作，包括：
    *   同步的网络请求
    *   复杂的数据解析 (JSON, Protobuf 等)
    *   大量的数据库读写
    *   复杂的文件操作
    *   CPU 密集型计算
*   **【推荐】任务延迟执行**: 将非启动所必需的任务（对用户看到首屏无直接影响）延迟到首页显示 (`viewDidAppear`) 之后，或放到后台队列异步执行。这包括：
    *   大部分第三方 SDK 的初始化 (除非 SDK 明确要求必须在 `didFinishLaunchingWithOptions` 完成)。
    *   非紧急的数据上报。
    *   预加载非首屏所需的数据。
    *   检查更新、权限请求等可以稍后处理的逻辑。
*   **【推荐】使用 `os_signpost` 标记**: 在 `didFinishLaunchingWithOptions` 的开始和结束，以及其中可能耗时的关键步骤（如 SDK 初始化）添加 `os_signpost` 标记，便于后续使用 Instruments 分析耗时。

### 3.2 SDK 初始化策略 (通用)

第三方 SDK 是常见的启动耗时来源。

*   **【建议】按需、延迟初始化**: 仔细阅读 SDK 文档，确认其**真正需要**的初始化时机。优先考虑将初始化延迟到首次使用该 SDK 功能时，或在首页显示后异步进行。
*   **【必须】避免在主线程同步初始化**: 对于已知或怀疑耗时的 SDK 初始化方法，**严禁**在主线程同步调用。如果必须同步，确保放到后台线程。
*   **【工具】使用 Clang 插件检查**: 利用团队维护的 Clang 插件 (`LaunchGuardPlugin`) 检查已知的耗时 SDK 是否在主线程被调用。

### 3.3 优化首页加载与渲染 (通用)

首页的加载和渲染速度直接影响用户感受到的启动时间 (T5)。

*   **【推荐】简化首页 UI 结构**: 避免首页视图层级过深、过度使用复杂的 AutoLayout 约束或视觉效果。
*   **【推荐】懒加载 UI 元素**: 对于非首屏立即可见的 UI 元素（例如 Tab Bar 的其他页面、侧边栏菜单内容），使用懒加载方式创建。
*   **【建议】避免在 `viewDidLoad` 中执行耗时操作**: `viewDidLoad` 也在启动关键路径上。将数据请求、复杂计算等移出 `viewDidLoad`，考虑在 `viewWillAppear` 或 `viewDidAppear` 中异步执行。
*   **【建议】使用数据缓存与预加载**: 对于首页需要展示的数据，优先使用本地缓存。如果需要网络请求，考虑：
    *   异步请求，并在请求期间显示占位符或骨架屏。
    *   如果数据相对稳定，考虑在 App 启动前（例如后台任务）进行预加载。
*   **【建议】优化图片加载**: 首页使用的大图应进行压缩，并考虑使用异步加载和缓存机制。

### 3.4 主线程使用规范 (通用)

*   **【强制】禁止在主线程执行任何长耗时操作**: 主线程必须保持流畅以响应用户交互和 UI 渲染。任何超过几十毫秒的操作都应放到后台队列执行。
*   **【工具】使用 Instruments Time Profiler**: 定期使用 Time Profiler 分析主线程是否存在意外的耗时操作。

## 4. 监控与工具

*   **【流程】关注 CI/CD 性能监控** (通用)
*   **【流程】使用静态分析工具**:
    *   **(OC)** 关注团队 Clang 插件 (`LaunchGuardPlugin`) 报告的警告。
    *   **(Swift)** **[待办]** 关注未来引入的 Swift 静态分析工具（如基于 SwiftSyntax 的自定义规则）报告的警告。
*   **【工具】熟练使用 Instruments** (通用)
*   **【流程】参考 APM 数据** (通用)

## 5. 附则

*   本规范自发布之日起生效。
*   团队将定期回顾和更新本规范。
*   如有疑问或建议，请联系 [负责人或技术委员会]。

**我们共同的目标是为用户提供流畅、快速的应用启动体验！**
